// Start of modification by B.L

using System;
using System.Linq;
using System.Numerics;

namespace KeePassLib.Shamir
{
    public sealed class ShamirSplit
    {
        readonly int n;
        readonly int k;
        readonly byte[] secret;
        readonly BigInteger[] coefficients;

        // this is the secret split into 8 byte arrays
        BigInteger[] coeff0_secrets;
        // array of n shares where each share is an array of parts (or coordinates)
        Part[][] shares;

        // prime number that is larger than all the share values
        // smallest 65 bit prime number
        // generated by taking the next biggest prime after the largest 64 bit prime
        // https://msdn.microsoft.com/en-us/library/ee621251.aspx
        BigInteger p = BigInteger.Parse("18446744073709551629");

        public ShamirSplit(byte[] secret, int n, int k, out int remainder)
        {
            this.secret = secret;
            this.n = n;
            this.k = k;
            this.coefficients = new BigInteger[k];
            int padding = 0;
            remainder = secret.Length % 8;
            
            Random rnd = new Random();

            //check if there will be a remainder when divided by 8
            if (secret.Length%8 > 0)
            {
                padding = 8 - secret.Length%8;
                
                //unsigned biginteger
                byte[] us = new byte[secret.Length + 1];
                Array.Copy(secret, 0, us, 0, secret.Length);

                // division for integers will ignore decimals (round down)
                this.coeff0_secrets = new BigInteger[(secret.Length / 8) + 1];

                if (secret.Length < 8)
                {
                    coeff0_secrets[0] = new BigInteger(us);
                }
                else
                {
                    for (int i = 0; i < secret.Length / 8; i++)
                    {
                        
                        byte[] secretPart = secret.Skip(8 * i).Take(8).ToArray();
                        byte[] unsignedPart = new byte[secretPart.Length + 1];
                        Array.Copy(secretPart, 0, unsignedPart, 0, secretPart.Length);

                        coeff0_secrets[i] = new BigInteger(unsignedPart);
                        var all = new BigInteger(secretPart);

                    }
                    byte[] secretPartRem = secret.Skip(8 * (secret.Length / 8)).Take(8 - padding).ToArray();
                    byte[] unsignedPartRem = new byte[secretPartRem.Length + 1];
                    Array.Copy(secretPartRem, 0, unsignedPartRem, 0, secretPartRem.Length);
                    coeff0_secrets[coeff0_secrets.Length-1] = new BigInteger(secretPartRem);
                }
                
            } else
            {
                this.coeff0_secrets = new BigInteger[(secret.Length / 8)];
                byte[] temp = new byte[9];
                for (int i = 0; i < secret.Length / 8; i++)
                {
                    Array.Copy(secret,i*8, temp, 0, 8);
                    coeff0_secrets[i] = new BigInteger(temp);
                }
            }
            
            var possibilities = Enumerable.Range(1, 100).ToList();
            var result = possibilities.OrderBy(number => rnd.Next()).Take(10).ToArray();
            for (int i = 0; i < k; i++)
            {
                coefficients[i] = new BigInteger(result[i]);
            }
        }

        public Part[][] Split()
        {
            int secretSize = coeff0_secrets.Length;
            Part[] parts = new Part[secretSize];

            //initialize the arrays
            shares = new Part[n][];
            for (int i=0; i<n;i++)
            {
                shares[i] = new Part[secretSize];
            }

            Random r = new Random();
            BigInteger secretPart = BigInteger.Zero;

            //this loop is for each partition of the secret
            for (int x = 0; x < secretSize; x++)
            {
                int x_value = 1;
                BigInteger[] sec_check = new BigInteger[secretSize];

                //this loop is for each share
                for (int z = 0; z < n; z++)
                {
                    BigInteger y_value = coeff0_secrets[x]; 

                    //this loop is to find the value of y given x (randomly generated)
                    // k represents the degree of the polynomial
                    for (int i = 1; i < this.k; i++)
                    {
                        BigInteger power = BigInteger.Pow(x_value, i);
                        BigInteger mult = BigInteger.Multiply(power, coefficients[i]);
                        y_value = BigInteger.Add(mult, y_value);

                    }
                    //taking the modulus of the result
                    y_value = System.Numerics.BigInteger.Remainder(y_value, p);
                    
                    shares[z][x] = new Part(new BigInteger(x_value++), y_value);
                }
            }

            return shares;
        }
    }
}

// End of modification by B.L